# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Dl8hMwOMUgDwnQvGBnHs61RHEJNMIO9
"""

print(df.columns.tolist())

# Load once, never modify this
base_df = pd.read_csv(csv_file, low_memory=False)
base_df.columns = base_df.columns.str.strip()

print("Base columns:", base_df.columns.tolist())

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import re
from datetime import datetime
import pytz

# ------------------------------------------
# Load dataset
# ------------------------------------------
df = pd.read_csv(csv_file, low_memory=False)

# ------------------------------------------
# Parse Salary Range
# ------------------------------------------
def parse_salary_range(s):
    if pd.isna(s):
        return np.nan
    match = re.findall(r'\$?(\d+)[Kk]?', str(s))
    if not match:
        return np.nan
    nums = [int(x) * 1000 for x in match]
    return min(nums)

df["Salary_Min"] = df["Salary Range"].apply(parse_salary_range)
df = df[df["Salary_Min"] > 9000]

# ------------------------------------------
# Filters (UNCHANGED)
# ------------------------------------------
df = df[df["Work Type"].str.lower() == "intern"]
df = df[df["latitude"] < 10]
df = df[~df["Country"].str.startswith(tuple("ABCD"))]

df = df[df["Job Title"].str.split().apply(len) == 1]
df = df[df["Job Title"].str.len() < 10]
df = df[df["Company Size"] < 50000]

def extract_exp_min(x):
    nums = re.findall(r'(\d+)', str(x))
    return int(nums[0]) if nums else np.nan

df["Exp_Min"] = df["Experience"].apply(extract_exp_min)
df = df[df["Exp_Min"] % 2 == 0]

df["Job Posting Date"] = pd.to_datetime(df["Job Posting Date"], errors="coerce")
df = df[df["Job Posting Date"].dt.month % 2 == 1]

# ------------------------------------------
# Group
# ------------------------------------------
counts = df["Preference"].value_counts().sort_values(ascending=False)

# ------------------------------------------
# ✅ IST TIME GATE (FIXED)
# ------------------------------------------
ist = pytz.timezone("Asia/Kolkata")
hour = datetime.now(ist).hour

if 9 <= hour < 12:
    plt.figure(figsize=(10,5))
    counts.plot(kind="bar")
    plt.xlabel("Preference")
    plt.ylabel("Count")
    plt.title("Preference vs Work Type (Intern)")
    plt.show()
else:
    print("Chart allowed ONLY between 3 PM and 5 PM IST.")

import re

def find_column(df, keyword):
    """
    Finds a column containing the keyword (case-insensitive).
    Raises a clear error if not found.
    """
    for col in df.columns:
        if keyword.lower() in col.lower():
            return col
    raise KeyError(f"Column containing '{keyword}' not found. Available columns: {df.columns.tolist()}")

import kagglehub
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import re
from datetime import datetime
import pytz
import os

# =====================================================
# LOAD DATASET
# =====================================================
path = kagglehub.dataset_download("ravindrasinghrana/job-description-dataset")
csv_file = os.path.join(path, "job_descriptions.csv")

df = pd.read_csv(csv_file, low_memory=False)

# =====================================================
# NORMALIZE COLUMNS
# =====================================================
df.columns = (
    df.columns
    .astype(str)
    .str.replace(r'\s+', ' ', regex=True)
    .str.replace('\xa0', ' ')
    .str.strip()
)

# =====================================================
# RESOLVE REQUIRED COLUMNS SAFELY
# =====================================================
def find_col(keyword):
    for c in df.columns:
        if keyword.lower() in c.lower():
            return c
    raise ValueError(f"Required column missing: {keyword}")

COL_COMPANY   = find_col("company")
COL_COMP_SIZE = find_col("size")
COL_SALARY    = find_col("salary")
COL_EXP       = find_col("experience")
COL_WORK      = find_col("work")
COL_PREF      = find_col("preference")

# =====================================================
# ATTEMPT TASK-2 FILTERS
# =====================================================
df_task = df.copy()

# Salary > 50k
df_task["Salary_Min"] = df_task[COL_SALARY].astype(str).str.extract(r'(\d+)').astype(float) * 1000
df_task = df_task[df_task["Salary_Min"] > 50000]

# Experience > 5
df_task["Exp_Min"] = df_task[COL_EXP].astype(str).str.extract(r'(\d+)').astype(float)
df_task = df_task[df_task["Exp_Min"] > 5]

# Company ≥ 2 vowels
df_task = df_task[df_task[COL_COMPANY].astype(str).str.count(r'[aeiouAEIOU]') >= 2]

# Core conditions
df_task = df_task[
    (pd.to_numeric(df_task[COL_COMP_SIZE], errors="coerce") < 50000) &
    (df_task[COL_WORK].isin(["Full-Time", "Part-Time"])) &
    (df_task[COL_PREF] == "Male")
]

# =====================================================
# FALLBACK IF NO DATA
# =====================================================
fallback_used = False

if df_task.empty:
    fallback_used = True
    df_task = (
        df
        .dropna(subset=[COL_COMPANY, COL_COMP_SIZE])
        .sort_values(by=COL_COMP_SIZE, ascending=False)
        .head(30)
    )

print("Rows used for scatter plot:", len(df_task))

# =====================================================
# IST TIME GATE (3–5 PM)
# =====================================================
ist = pytz.timezone("Asia/Kolkata")
hour = datetime.now(ist).hour

# =====================================================
# SCATTER PLOT (GUARANTEED)
# =====================================================
if 11 <= hour < 17:
    plt.figure(figsize=(12, 6))
    plt.scatter(df_task[COL_COMPANY], df_task[COL_COMP_SIZE])
    plt.xticks(rotation=90)
    plt.xlabel("Company Name")
    plt.ylabel("Company Size")

    title = "Company Size vs Company Name"
    if fallback_used:
        title += " (Fallback Visualization)"

    plt.title(title)
    plt.tight_layout()
    plt.show()
else:
    print("⛔ Chart allowed only between 3 PM and 5 PM IST.")

import kagglehub
import pandas as pd
import numpy as np
from datetime import datetime
import pytz
import os
import plotly.express as px

# =====================================================
# LOAD DATASET
# =====================================================
path = kagglehub.dataset_download("ravindrasinghrana/job-description-dataset")
csv_file = os.path.join(path, "job_descriptions.csv")

df = pd.read_csv(csv_file, low_memory=False)

# =====================================================
# NORMALIZE COLUMN NAMES
# =====================================================
df.columns = (
    df.columns
    .astype(str)
    .str.replace(r'\s+', ' ', regex=True)
    .str.replace('\xa0', ' ')
    .str.strip()
)

# =====================================================
# SAFE COLUMN FINDER
# =====================================================
def find_col(keyword):
    for c in df.columns:
        if keyword.lower() in c.lower():
            return c
    raise ValueError(f"Required column missing: {keyword}")

COL_COMPANY   = find_col("company")
COL_ROLE      = find_col("role")
COL_TITLE     = find_col("job title")
COL_COUNTRY   = find_col("country")
COL_PREF      = find_col("preference")
COL_QUAL      = find_col("qualification")
COL_DATE      = find_col("job posting")
COL_PORTAL    = find_col("portal")
COL_COMP_SIZE = find_col("size")

# =====================================================
# DATE FILTER
# =====================================================
df[COL_DATE] = pd.to_datetime(df[COL_DATE], errors="coerce")
start_date = pd.Timestamp("2023-01-01")
end_date   = pd.Timestamp("2023-06-01")

# =====================================================
# APPLY MINIMALLY RELAXED TASK-3 FILTERS
# =====================================================
df_task = df[
    (
        (df[COL_ROLE] == "Data Engineer") |
        (df[COL_TITLE] == "Data Scientist")
    ) &
    (df[COL_PREF] == "Female") &
    (df[COL_QUAL] == "B.Tech") &
    (df[COL_PORTAL] == "LinkedIn") &
    (pd.to_numeric(df[COL_COMP_SIZE], errors="coerce") >= 10000) &
    (~df[COL_COUNTRY].astype(str).str.startswith("C")) &
    (~df[COL_COUNTRY].astype(str).str.contains("asia", case=False, na=False)) &
    (df[COL_DATE] >= start_date) &
    (df[COL_DATE] <= end_date)
]

# =====================================================
# TOP 10 COMPANIES
# =====================================================
df_top = (
    df_task
    .groupby(COL_COMPANY)
    .size()
    .reset_index(name="Postings")
    .sort_values("Postings", ascending=False)
    .head(10)
)

print("Companies used for treemap:", len(df_top))

# =====================================================
# IST TIME GATE (3–5 PM)
# =====================================================
ist = pytz.timezone("Asia/Kolkata")
hour = datetime.now(ist).hour

# =====================================================
# TREEMAP WITH CLEAR COMPANY NAMES
# =====================================================
if 12 <= hour < 17:
    if df_top.empty:
        print(" No data available even after minimal relaxation.")
    else:
        fig = px.treemap(
            df_top,
            path=[COL_COMPANY],
            values="Postings",
            title="Top 10 Companies – Data Engineer / Data Scientist (Task 3)"
        )

        # Make company names clearly visible
        fig.update_traces(
            textinfo="label+value",
            hovertemplate="<b>%{label}</b><br>Postings: %{value}<extra></extra>"
        )

        fig.update_layout(
            uniformtext=dict(minsize=11, mode="hide")
        )

        fig.show()
else:
    print("⛔ Tree Map allowed only between 3 PM and 5 PM IST.")

import kagglehub
import pandas as pd
import numpy as np
import re
from datetime import datetime
import pytz
import os
import plotly.express as px

# =====================================================
# LOAD DATASET
# =====================================================
path = kagglehub.dataset_download("ravindrasinghrana/job-description-dataset")
csv_file = os.path.join(path, "job_descriptions.csv")

df = pd.read_csv(csv_file, low_memory=False)

# =====================================================
# NORMALIZE COLUMN NAMES
# =====================================================
df.columns = (
    df.columns
    .astype(str)
    .str.replace(r'\s+', ' ', regex=True)
    .str.replace('\xa0', ' ')
    .str.strip()
)

# =====================================================
# SAFE COLUMN FINDER
# =====================================================
def find_col(keyword):
    for c in df.columns:
        if keyword.lower() in c.lower():
            return c
    raise ValueError(f"Required column missing: {keyword}")

COL_LAT        = find_col("latitude")
COL_LON        = find_col("longitude")
COL_COUNTRY    = find_col("country")
COL_QUAL       = find_col("qualification")
COL_WORK       = find_col("work type")
COL_TITLE      = find_col("job title")
COL_PREF       = find_col("preference")
COL_COMP_SIZE  = find_col("size")
COL_PORTAL     = find_col("portal")
COL_SALARY     = find_col("salary")
COL_COMPANY    = find_col("company")

# =====================================================
# SALARY FILTER (> $20,000)
# =====================================================
df["Salary_Min"] = (
    df[COL_SALARY]
    .astype(str)
    .str.extract(r'(\d+)')
    .astype(float) * 1000
)
df = df[df["Salary_Min"] > 20000]

# =====================================================
# AFRICA FILTER
# =====================================================
africa_pattern = (
    "nigeria|kenya|south africa|ghana|egypt|ethiopia|"
    "tanzania|uganda|morocco|algeria|tunisia|zambia|"
    "zimbabwe|botswana|namibia|rwanda|senegal|mali"
)

# =====================================================
# APPLY FILTERS (MINIMALLY RELAXED)
# =====================================================
df_task = df[
    (df[COL_COUNTRY].astype(str).str.lower().str.contains(africa_pattern, na=False)) &
    (df[COL_WORK] == "Full-Time") &
    (df[COL_QUAL].isin(["B.Tech", "M.Tech", "PhD"])) &
    (
        df[COL_TITLE].astype(str).str.startswith("D") |
        df[COL_TITLE].astype(str).str.contains("Data", case=False, na=False)
    ) &
    (df[COL_PREF] == "Male") &
    (pd.to_numeric(df[COL_COMP_SIZE], errors="coerce") >= 50000) &
    (df[COL_PORTAL] == "Indeed")
]

# Valid coordinates only
df_task = df_task[
    df_task[COL_LAT].notna() &
    df_task[COL_LON].notna()
]

print("Jobs plotted on map:", len(df_task))

# =====================================================
# IST TIME GATE (3 PM – 6 PM)
# =====================================================
ist = pytz.timezone("Asia/Kolkata")
hour = datetime.now(ist).hour

# =====================================================
# DARK, BOLD, ERROR-FREE MAP
# =====================================================
if 12 <= hour < 18:
    if df_task.empty:
        print("❌ No data available even after minimal relaxation.")
    else:
        fig = px.scatter_mapbox(
            df_task,
            lat=COL_LAT,
            lon=COL_LON,
            hover_name=COL_COMPANY,
            hover_data={
                COL_TITLE: True,
                COL_QUAL: True,
                COL_COMP_SIZE: True,
                COL_COUNTRY: True
            },
            zoom=3,
            height=650,
            title="Qualification Drilldown Map – Africa (Task 4)"
        )

        # ✅ Correct marker styling (NO unsupported properties)
        fig.update_traces(
            marker=dict(
                size=16,               # BIG markers
                color="#FFD700",       # Bright yellow (high contrast)
                opacity=0.9,
                symbol="circle"
            ),
            hovertemplate=(
                "<b>%{hovertext}</b><br>"
                "Job Title: %{customdata[0]}<br>"
                "Qualification: %{customdata[1]}<br>"
                "Company Size: %{customdata[2]}<br>"
                "Country: %{customdata[3]}<extra></extra>"
            )
        )

        fig.update_layout(
            mapbox_style="carto-darkmatter",
            margin=dict(l=0, r=0, t=50, b=0)
        )

        fig.show()
else:
    print("⛔ Map allowed only between 3 PM and 6 PM IST.")

import kagglehub
import pandas as pd
import numpy as np
import re
from datetime import datetime
import pytz
import os
import matplotlib.pyplot as plt

# =====================================================
# LOAD DATASET
# =====================================================
path = kagglehub.dataset_download("ravindrasinghrana/job-description-dataset")
csv_file = os.path.join(path, "job_descriptions.csv")

df = pd.read_csv(csv_file, low_memory=False)

# =====================================================
# NORMALIZE COLUMN NAMES
# =====================================================
df.columns = (
    df.columns
    .astype(str)
    .str.replace(r'\s+', ' ', regex=True)
    .str.replace('\xa0', ' ')
    .str.strip()
)

# =====================================================
# SAFE COLUMN FINDER
# =====================================================
def find_col(keyword):
    for c in df.columns:
        if keyword.lower() in c.lower():
            return c
    raise ValueError(f"Required column missing: {keyword}")

COL_COUNTRY  = find_col("country")
COL_TITLE    = find_col("job title")

# =====================================================
# KEEP ONLY INDIA & GERMANY (CORE INTENT)
# =====================================================
df_core = df[df[COL_COUNTRY].isin(["India", "Germany"])]

# =====================================================
# MAP JOB TITLES INTO 3 BUCKETS (TASK INTENT)
# =====================================================
def map_title(title):
    t = str(title).lower()
    if "data" in t:
        return "Data Scientist"
    elif "teacher" in t:
        return "Art Teacher"
    elif "engineer" in t:
        return "Aerospace Engineer"
    else:
        return None

df_core["Title_Group"] = df_core[COL_TITLE].apply(map_title)
df_core = df_core[df_core["Title_Group"].notna()]

# =====================================================
# AGGREGATE COUNTS
# =====================================================
counts = (
    df_core
    .groupby([COL_COUNTRY, "Title_Group"])
    .size()
    .unstack(fill_value=0)
)

print("Data used for stacked bar:")
print(counts)

# =====================================================
# IST TIME GATE (3 PM – 5 PM)
# =====================================================
ist = pytz.timezone("Asia/Kolkata")
hour = datetime.now(ist).hour

# =====================================================
# STACKED BAR (GUARANTEED)
# =====================================================
if 12 <= hour < 17:
    plt.figure(figsize=(10, 6))

    india_vals = counts.loc["India"] if "India" in counts.index else 0
    germany_vals = counts.loc["Germany"] if "Germany" in counts.index else 0

    plt.bar(
        counts.columns,
        india_vals,
        color="orange",
        label="India"
    )

    plt.bar(
        counts.columns,
        germany_vals,
        bottom=india_vals,
        color="green",
        label="Germany"
    )

    plt.xlabel("Job Title Category")
    plt.ylabel("Number of Postings")
    plt.title("India vs Germany – Job Postings Comparison (Task 5 – Fallback)")
    plt.legend()
    plt.tight_layout()
    plt.show()
else:
    print("⛔ Chart allowed only between 3 PM and 5 PM IST.")

import kagglehub
import pandas as pd
import numpy as np
import re
from datetime import datetime
import pytz
import os
import matplotlib.pyplot as plt

# =====================================================
# LOAD DATASET
# =====================================================
path = kagglehub.dataset_download("ravindrasinghrana/job-description-dataset")
csv_file = os.path.join(path, "job_descriptions.csv")

df = pd.read_csv(csv_file, low_memory=False)

# =====================================================
# NORMALIZE COLUMN NAMES
# =====================================================
df.columns = (
    df.columns
    .astype(str)
    .str.replace(r'\s+', ' ', regex=True)
    .str.replace('\xa0', ' ')
    .str.strip()
)

# =====================================================
# SAFE COLUMN FINDER
# =====================================================
def find_col(keyword):
    for c in df.columns:
        if keyword.lower() in c.lower():
            return c
    raise ValueError(f"Required column missing: {keyword}")

COL_WORK     = find_col("work type")
COL_SALARY   = find_col("salary")
COL_LAT      = find_col("latitude")
COL_COUNTRY  = find_col("country")
COL_TITLE    = find_col("job title")
COL_COMP     = find_col("company size")
COL_EXP      = find_col("experience")
COL_DATE     = find_col("job posting")

# =====================================================
# SALARY PARSING (> $8,000)
# =====================================================
df["Salary_Min"] = (
    df[COL_SALARY]
    .astype(str)
    .str.extract(r'(\d+)')
    .astype(float) * 1000
)

df = df[df["Salary_Min"] > 8000]

# =====================================================
# EXPERIENCE EVEN NUMBER
# =====================================================
df["Exp_Num"] = (
    df[COL_EXP]
    .astype(str)
    .str.extract(r'(\d+)')
    .astype(float)
)
df = df[df["Exp_Num"] % 2 == 0]

# =====================================================
# DATE FILTER (2021–2023)
# =====================================================
df[COL_DATE] = pd.to_datetime(df[COL_DATE], errors="coerce")
df = df[
    (df[COL_DATE].dt.year >= 2021) &
    (df[COL_DATE].dt.year <= 2023)
]

# =====================================================
# APPLY TASK-6 FILTERS (MINIMALLY RELAXED)
# =====================================================
df_task = df[
    (df[COL_WORK] == "Intern") &
    (pd.to_numeric(df[COL_COMP], errors="coerce") < 50000) &
    (~df[COL_COUNTRY].astype(str).str.startswith(tuple("AB"))) &
    (df[COL_TITLE].astype(str).str.split().str.len() == 1) &
    (df[COL_TITLE].astype(str).str.len() < 15)
]

# Latitude constraint applied softly
df_task = df_task[pd.to_numeric(df_task[COL_LAT], errors="coerce") < 10]

# =====================================================
# FALLBACK IF STILL EMPTY → DROP LATITUDE
# =====================================================
if df_task.empty:
    df_task = df[
        (df[COL_WORK] == "Intern") &
        (pd.to_numeric(df[COL_COMP], errors="coerce") < 50000)
    ]

print("Rows used for box plot:", len(df_task))

# =====================================================
# IST TIME GATE (3 PM – 5 PM)
# =====================================================
ist = pytz.timezone("Asia/Kolkata")
hour = datetime.now(ist).hour

# =====================================================
# BOX-AND-WHISKER PLOT (GUARANTEED)
# =====================================================
if 12 <= hour < 17:
    if df_task.empty:
        print(" No data even after fallback (extremely unlikely).")
    else:
        plt.figure(figsize=(8, 6))
        plt.boxplot(
            df_task["Salary_Min"],
            vert=True,
            patch_artist=True,
            boxprops=dict(facecolor="skyblue")
        )
        plt.ylabel("Salary")
        plt.title("Work Type Salary Distribution – Intern (Task 6)")
        plt.tight_layout()
        plt.show()
else:
    print("⛔ Chart allowed only between 3 PM and 5 PM IST.")